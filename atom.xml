<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>十三画的博客</title>
  
  <subtitle>人各有价，千万不要活得太便宜</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-12-26T08:06:05.773Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>十三画</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>TCP/IP协议</title>
    <link href="http://yoursite.com/2019/12/24/TCP-IP%E5%8D%8F%E8%AE%AE/"/>
    <id>http://yoursite.com/2019/12/24/TCP-IP%E5%8D%8F%E8%AE%AE/</id>
    <published>2019-12-24T10:20:01.000Z</published>
    <updated>2019-12-26T08:06:05.773Z</updated>
    
    <content type="html"><![CDATA[<h2 id="网络基础TCP-IP"><a href="#网络基础TCP-IP" class="headerlink" title="网络基础TCP/IP"></a>网络基础TCP/IP</h2><p>为了理解http，我们有必要事先了解一下TCP/IP协议族。</p><p>通常使用的网络（包括互联网）是在TCP/IP的基础上运作的，而HTTP属于它的一个子集。</p><p>计算机与网络设备要相互通信，双方就必须基于相同的方法。如，如何探测到通信目标、有哪一边先发起通信、使用哪种语言进行通信、怎样结束通信等规则都需要事先确定。不同的硬件、操作系统之间的通信，所有的这一切都需要一种规则。而我们把这种规则称为<code>协议(protocol)</code>。把与互联网相关联的协议集合起来总称为<code>TCP/IP</code>。也有一种说法认为TCP/IP是指TCP和IP这两种协议，还有一种说法认为TCP/IP是在IP协议的通信过程中，使用到的协议族的总称。</p><h3 id="TCP-IP的分层管理"><a href="#TCP-IP的分层管理" class="headerlink" title="TCP/IP的分层管理"></a>TCP/IP的分层管理</h3><p>TCP/IP协议族按层次分别分为4层：<code>应用层、传输层、网络层、数据链路层</code>。</p><p>类似于代码的模块化，无疑TCP/IP协议族分层是很有好处的，各层各司其职互不干扰，如果需要更换其中的某一层只需换掉这一层即可。</p><p>各层作用如下：</p><ol><li><p>应用层<br>应用层决定了向用户提供应用服务时的通信活动。TCP/IP协议族内预存了各类通用的应用服务。比如：FTP(File Transfer Protocol 文件传输协议)和DNS(Domain Name System 域名系统)就是其中的两类。<code>HTTP协议也处于该层</code>。</p></li><li><p>传输层<br>传输层对上层应用层提供处于网络连接中的两台计算机之间的数据传输。</p></li></ol><p>在传输层有两个性质不同的协议：TCP(Transmission Control Protocol 传输控制协议)和UDP(User Data Protocol 用户数据报协议)</p><ol start="3"><li><p>网络层<br>网络层又名网络互连层。网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数据单位。该层规定了通过怎样的路径（所谓的传输路线）到达对方计算机，并把数据包传送给对方。</p></li><li><p>数据链路层<br>数据链路层又名链路层、网络接口层。用来处理网路的硬件部分。包括控制操作系统、硬件的设备驱动、NIC(Network Interface Card 网络适配器即 网卡)，及光纤等物理可见部分（还包括连接等一切传输媒介）。硬件上的范畴均在数据链路层的作用范围之内。</p></li></ol><h2 id="TCP-IP通信传输"><a href="#TCP-IP通信传输" class="headerlink" title="TCP/IP通信传输"></a>TCP/IP通信传输</h2><p>发送端从应用层往下走，接收端从数据链路层往上走</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;网络基础TCP-IP&quot;&gt;&lt;a href=&quot;#网络基础TCP-IP&quot; class=&quot;headerlink&quot; title=&quot;网络基础TCP/IP&quot;&gt;&lt;/a&gt;网络基础TCP/IP&lt;/h2&gt;&lt;p&gt;为了理解http，我们有必要事先了解一下TCP/IP协议族。&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
    
    
      <category term="TCP/IP协议" scheme="http://yoursite.com/tags/TCP-IP%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>canvas优化</title>
    <link href="http://yoursite.com/2019/12/24/canvas%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2019/12/24/canvas%E4%BC%98%E5%8C%96/</id>
    <published>2019-12-24T10:14:49.000Z</published>
    <updated>2019-12-26T08:47:01.523Z</updated>
    
    <content type="html"><![CDATA[<p>canvas是HTML5出的一个标签，用js控制绘制图形。canvas标签一定要有width和height，不能在style中定义width和height，否则会出现变形、缩放等一系列问题。</p><p>我们先来了解一下canvas的渲染</p><p><code>canvas上下文是状态机</code>canvas API 都在其上下文对象context<br>上抵用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const context = canvas.getContext(&apos;2d&apos;);</span><br></pre></td></tr></table></figure></p><p>context是一个状态机。你可以改变context的若干状态，而几乎所有的渲染操作，最终的效果与context本身的状态有关系。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">context.lineWidth = 5;</span><br><span class="line">context.strokeStyle=&quot;f00&quot;</span><br><span class="line">context.strokeRect(100,100,200,200)</span><br></pre></td></tr></table></figure><p>context.lineWidth 的赋值开销要远远大于普通对象赋值的开销。context不是一个普通的对象，当你调用了context.lineWidth = 5 时，浏览器会需要立刻去做一些事情，这样你下次调用诸如stroke或strokeRect等API时，画出来的正好是5px宽了。（不难想象，这也是一种优化，否则，这些事情就要等到下次stroke之前做，更加会影响性能）。</p><p>我们执行以下赋值操作10^6次</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 10^6times</span><br><span class="line">somePlainObject.lineWidth = 5;  // 3ms </span><br><span class="line">context.lineWidth = 5;  // 40ms</span><br><span class="line">context.lineWidth = &apos;Hello World!&apos;; // 140ms</span><br><span class="line">context.lineWidth = &#123;&#125;; // 600ms</span><br></pre></td></tr></table></figure><p>参考文章<br>MDN：canvas 性能 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial/Optimizing_canvas" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial/Optimizing_canvas</a></p><p>Canvas 最佳实践（性能篇）：<a href="https://fed.taobao.org/blog/taofed/do71ct/canvas-performance/?spm=taofed.blogs.blog-list.2.6b365ac8l8NLf9" target="_blank" rel="noopener">https://fed.taobao.org/blog/taofed/do71ct/canvas-performance/?spm=taofed.blogs.blog-list.2.6b365ac8l8NLf9</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;canvas是HTML5出的一个标签，用js控制绘制图形。canvas标签一定要有width和height，不能在style中定义width和height，否则会出现变形、缩放等一系列问题。&lt;/p&gt;
&lt;p&gt;我们先来了解一下canvas的渲染&lt;/p&gt;
&lt;p&gt;&lt;code&gt;can
      
    
    </summary>
    
    
    
      <category term="canvas" scheme="http://yoursite.com/tags/canvas/"/>
    
  </entry>
  
  <entry>
    <title>mpvue微信小程序踩坑笔记(一)</title>
    <link href="http://yoursite.com/2019/01/19/wx-study-1/"/>
    <id>http://yoursite.com/2019/01/19/wx-study-1/</id>
    <published>2019-01-19T06:22:47.000Z</published>
    <updated>2019-12-24T10:11:46.525Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/13hua" target="_blank" rel="noopener">demo源码</a></p><p>mpvue可以使用vue的基本语法来开发小程序，可以使用vux，flyio等来辅助开发，方便快捷高效开发。当然这其中还有诸多限制。<br>官方文档指出的问题就不一一罗列了，不清楚的童鞋请看这里 mpvue官方文档</p><p>另外看到了一份写的还不错的<a href="https://github.com/noahlam/articles/blob/master/%E7%BE%8E%E5%9B%A2%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6mpvue%E8%B9%B2%E5%9D%91%E6%8C%87%E5%8D%97.md" target="_blank" rel="noopener">踩坑指南</a> ，共勉</p><p>下面来说说我踩的坑。</p><h2 id="一、-swiper组件的问题"><a href="#一、-swiper组件的问题" class="headerlink" title="一、 swiper组件的问题"></a>一、 swiper组件的问题</h2><h4 id="1-swiper组件自适应高度问题"><a href="#1-swiper组件自适应高度问题" class="headerlink" title="1. swiper组件自适应高度问题"></a>1. swiper组件自适应高度问题</h4><p>解决思路是：获取屏幕宽度，获取图片的宽高，然后等比设置当前屏幕宽度下swiper的高度。因为load事件只在图片第一次加载的时候执行，所以取所有图片高度的最大值即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;swiper :current=&quot;currSwiperItem&quot; skip-hidden-item-layout=&quot;true&quot; @change=&quot;switchItem(&apos;switchItem&apos;,$event)&quot; :style=&quot;swiperImgH&quot;&gt;</span><br><span class="line">  &lt;swiper-item v-for=&quot;(list,index) in swiperList&quot; :key=&quot;index&quot;&gt;</span><br><span class="line">    &lt;img  class=&quot;img&quot; :src=&quot;list.imgPath&quot; @load=&quot;calcImgH&quot; mode=&quot;widthFix&quot; alt=&quot;&quot;&gt;</span><br><span class="line">  &lt;/swiper-item&gt;</span><br><span class="line">&lt;/swiper&gt;　</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">  * 动态计算swiper图片的高度</span><br><span class="line">  */</span><br><span class="line">calcImgH: async function (e) &#123;</span><br><span class="line">  let winWidth = wx.getSystemInfoSync().windowWidth; // 获取当前屏幕的宽度</span><br><span class="line">  let imgH = e.mp.detail.height; // 图片高度</span><br><span class="line">  let imgW = e.mp.detail.width;</span><br><span class="line">  if (imgH &gt; this.curImgH) &#123;</span><br><span class="line">    this.curImgH = imgH;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  this.swiperImgH = `height:$&#123;winWidth * this.curImgH / imgW&#125;px`;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p><h4 id="2-swiper组件的current一定要写，如果不写就会出现只显示两张图片，从第三张开始高度均为0-如果出现这种问题，请优先查看是否定义了current"><a href="#2-swiper组件的current一定要写，如果不写就会出现只显示两张图片，从第三张开始高度均为0-如果出现这种问题，请优先查看是否定义了current" class="headerlink" title="2. swiper组件的current一定要写，如果不写就会出现只显示两张图片，从第三张开始高度均为0.如果出现这种问题，请优先查看是否定义了current"></a>2. swiper组件的current一定要写，如果不写就会出现只显示两张图片，从第三张开始高度均为0.如果出现这种问题，请优先查看是否定义了current</h4><h2 id="二、v-show不能使用，请使用v-if，具体原因应该是mpvue的问题，可能是编译的时候出了问题没有编译成wx：show"><a href="#二、v-show不能使用，请使用v-if，具体原因应该是mpvue的问题，可能是编译的时候出了问题没有编译成wx：show" class="headerlink" title="二、v-show不能使用，请使用v-if，具体原因应该是mpvue的问题，可能是编译的时候出了问题没有编译成wx：show"></a>二、<code>v-show</code>不能使用，请使用<code>v-if</code>，具体原因应该是<code>mpvue</code>的问题，可能是编译的时候出了问题没有编译成<code>wx：show</code></h2><h2 id="三、canvas保存图片的时候显示的是上一张图片，这里需要做重置处理，这个不是mpvue的问题"><a href="#三、canvas保存图片的时候显示的是上一张图片，这里需要做重置处理，这个不是mpvue的问题" class="headerlink" title="三、canvas保存图片的时候显示的是上一张图片，这里需要做重置处理，这个不是mpvue的问题"></a>三、canvas保存图片的时候显示的是上一张图片，这里需要做重置处理，这个不是mpvue的问题</h2><h2 id="四、关于文件命名问题"><a href="#四、关于文件命名问题" class="headerlink" title="四、关于文件命名问题"></a>四、关于文件命名问题</h2><p>例如：我想把 <code>/pages/list/index.vue</code> 中的js代码提出来 单独放在 <code>/pageslist/index.js</code>中，这个时候这个<code>index.js</code>文件命名就有问题了，在微信开发工具中会提示找不到<code>/pages/list/main.wxml</code> 文件，我想可能是因为<code>list</code>下出现了两个<code>index</code>文件<code>mpvue</code>不知道编译哪一个，所以才出现了问题的吧，把<code>js</code>文件改成除了<code>index</code>外的任何名字就好了。</p><h2 id="五、vux的使用，在utils等纯js文件中使用store-在vue中我们会使用引入文件的方式使用，没有任何问题，"><a href="#五、vux的使用，在utils等纯js文件中使用store-在vue中我们会使用引入文件的方式使用，没有任何问题，" class="headerlink" title="五、vux的使用，在utils等纯js文件中使用store,在vue中我们会使用引入文件的方式使用，没有任何问题，"></a>五、vux的使用，在utils等纯js文件中使用store,在vue中我们会使用引入文件的方式使用，没有任何问题，</h2><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import store from &apos;./store.js&apos; </span><br><span class="line"> </span><br><span class="line">console.log(store.status);</span><br></pre></td></tr></table></figure><p>但是在<code>mpvue</code>中这样直接引入<code>store</code>使用是有问题的,这样写不会报错，在<code>mpvue</code>中这里的<code>store</code>和<code>vue</code>实例中的<code>this.$store</code>不是同一个实例，即 这里的<code>store.status !== this.$store.status</code>。也就是说修改<code>store.status</code>的值，<code>this.$store.status</code>并不会做任何的改变，他们俩没有关系。</p><h2 id="六、canvas-问题"><a href="#六、canvas-问题" class="headerlink" title="六、canvas 问题"></a>六、canvas 问题</h2><p>因为<code>canvas</code>使用的是原生组件，<code>z-index</code>并不会影响它的层级，永远是在最上层的，如果需要做弹窗遮罩就需要使用 <code>cover-view</code> 或者<code>cover-image</code> ，这里需要注意的是<code>cover-view</code> 或者<code>cover-image</code>必须要写在<code>canvas</code>上下文的后面，如果写在前面还是一样无法遮住。</p><h2 id="七、scroll-view-上拉加载下拉刷新"><a href="#七、scroll-view-上拉加载下拉刷新" class="headerlink" title="七、scroll-view 上拉加载下拉刷新"></a>七、scroll-view 上拉加载下拉刷新</h2><p>在<code>@touchend=&quot;scrollTouchEnd&quot;</code> 事件中 对满足条件的 <code>scroll-top</code> 赋值之后并没有 并没有页面做出实质对的改变，因为对同一个值做相同的复制操作的时候<code>mpvue</code>并没有执行这个赋值动作，解决方法是再赋一个不同的值，这样就会做出改变了，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">scrollTouchEnd() &#123;</span><br><span class="line">  console.log(&apos;scrollTouchEnd&apos;);</span><br><span class="line"></span><br><span class="line">  if (this.scrollingTop &lt; 80) &#123;</span><br><span class="line">    console.log(&apos;下拉刷新&apos;);</span><br><span class="line">    this.refresh();</span><br><span class="line">    this.scrolledTop = 0;</span><br><span class="line">    this.scrolledTop = 80;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (this.scrollHeight - this.scrollingTop - this.scrollWrapHeight &lt;= 80) &#123;</span><br><span class="line">    console.log(&apos;上拉加载&apos;);</span><br><span class="line">    this.loadMore();</span><br><span class="line">    this.scrolledTop = this.scrollHeight - this.scrollWrapHeight;</span><br><span class="line">    this.scrolledTop = this.scrollHeight - this.scrollWrapHeight - 80;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong><em>愿圣光与你同在！</em></strong></p><p>如本文有任何问题欢迎指正，谢谢！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://github.com/13hua&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;demo源码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;mpvue可以使用vue的基本语法来开发小程序，可以使用vux，flyio等来辅助开发，方便快捷高效开发。
      
    
    </summary>
    
    
    
      <category term="mpvue" scheme="http://yoursite.com/tags/mpvue/"/>
    
  </entry>
  
  <entry>
    <title>关于单元测试mocha的学习笔记</title>
    <link href="http://yoursite.com/2018/11/03/mocha/"/>
    <id>http://yoursite.com/2018/11/03/mocha/</id>
    <published>2018-11-03T14:42:49.000Z</published>
    <updated>2019-12-24T09:45:49.705Z</updated>
    
    <content type="html"><![CDATA[<p>自出道以来一直想写个单元测试来的，但是一直都在想，终于今天开始写了，也算迈出了小小的一步。</p><h1 id="INSTALLATION-安装"><a href="#INSTALLATION-安装" class="headerlink" title="INSTALLATION(安装)"></a>INSTALLATION(安装)</h1><p>全局安装，(非必需，虽然很多文章都要求全局安装，但是廖雪峰大大建议尽量不要全局安装，因为全局模块会影响到所有 Node.js 的工程)</p><p><code>npm install --global mocha</code></p><p>项目局部安装</p><p><code>npm install --save-dev mocha</code></p><p>如果 npm 网速比较慢，建议使用 yarn。</p><h1 id="GETTING-STARTED-起步"><a href="#GETTING-STARTED-起步" class="headerlink" title="GETTING STARTED(起步)"></a>GETTING STARTED(起步)</h1><p>新建项目，并在项目中安装 mocha。新建一个 test 文件夹，所有的 test 文件就都放在这个文件夹下，mocha 默认会执行 test 目录下的所有测试，不要去改变默认目录。</p><p>在 test.js 中写下如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var assert = require(&apos;assert&apos;);</span><br><span class="line">describe(&apos;Array&apos;, function() &#123;</span><br><span class="line">  describe(&apos;#indexOf()&apos;, function() &#123;</span><br><span class="line">    it(&apos;should return -1 when the value is not present&apos;, function() &#123;</span><br><span class="line">      assert.equal([1,2,3].indexOf(4), -1);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>启动终端/命令行工具(git bash)，在当前项目目录下 输入命令 mocha</p><p><code>mocha</code><br>运行结果如下：</p><p><img src="/2018/11/03/mocha/1.png" alt="运行结果" title="运行结果"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">lenovo@LAPTOP-QGCH84J8 MINGW64 /e/workSpace/study/1-单元测试/test</span><br><span class="line">$ mocha</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  Array</span><br><span class="line">    #indexOf()</span><br><span class="line">      √ should return -1 when the value is not present</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  1 passing (5ms)</span><br></pre></td></tr></table></figure><p>在 package.json 中设置脚本:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;mocha&quot;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>然后运行测试：<br><code>npm test</code></p><h1 id="mocha-的两个函数"><a href="#mocha-的两个函数" class="headerlink" title="mocha 的两个函数"></a>mocha 的两个函数</h1><p>mocha 是一个测试框架，即组织并执行测试。写测试的时候要调用两个基本的函数：描述函数 describe()和它函数 it(),在上面的例子中都有用到。</p><ol><li>描述函数 describe()是 mocha 将测试分组的一种方法，可以把多个测试嵌套在一个组里，想要嵌套多深就嵌套多深。describe()有两个参数，第一个是测试组的名字，第二个是实际执行的函数。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">describe(&apos;string name&apos;,function()&#123;</span><br><span class="line"></span><br><span class="line">// 这里可以嵌套更多的描述函数describe()，也可以写实际的测试。</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="2"><li>它函数 it()用于单独的测试用例。在一个 describe()中可以嵌套多个 it()函数。it()函数有两个参数，第一个参数是一个字符串说明测试的目的，第二个是实际执行的函数，里面是具体的测试。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">it(&apos;it name&apos;,function()&#123;</span><br><span class="line">    // 在这里写测试用例</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="编写-js-模块文件的测试脚本"><a href="#编写-js-模块文件的测试脚本" class="headerlink" title="编写 js 模块文件的测试脚本"></a>编写 js 模块文件的测试脚本</h1><p>在项目中添加 add.js 文件，并在其中添加如下 add 模块代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//add.js</span><br><span class="line">function add(a, b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = add;</span><br></pre></td></tr></table></figure><p>添加 test/add.test.js 文件，并在其中添加 add 的测试脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// add.test.js</span><br><span class="line"></span><br><span class="line">var assert = require(&apos;assert&apos;);</span><br><span class="line"></span><br><span class="line">var add = require(&apos;../add.js&apos;);</span><br><span class="line"></span><br><span class="line">describe(&apos;add函数的测试&apos;, function () &#123;</span><br><span class="line">    it(&apos;3加4应该等于7&apos;, function () &#123;</span><br><span class="line">        assert.equal(add(3, 4), 7);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在终端输入<br><code>npm test</code></p><p>终端运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">lenovo@LAPTOP-QGCH84J8 MINGW64 /e/workSpace/study/1-单元测试/test</span><br><span class="line">$ npm test</span><br><span class="line"></span><br><span class="line">&gt; @ test E:\workSpace\study\1-单元测试\test</span><br><span class="line">&gt; mocha</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  add函数的测试</span><br><span class="line">    √ 3加4应该等于7</span><br><span class="line"></span><br><span class="line">  Array</span><br><span class="line">    #indexOf()</span><br><span class="line">      √ should return -1 when the value is not present</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  2 passing (6ms)</span><br></pre></td></tr></table></figure><h1 id="多次调用-done"><a href="#多次调用-done" class="headerlink" title="多次调用 done()"></a>多次调用 done()</h1><p>如果使用基于回调的异步测试，如果 mocha 多次调用 done(),则会抛出 Error，这对于捕获意外的多次回调非常方便。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">it(&apos;double done&apos;, function(done) &#123;</span><br><span class="line">  // Calling `done()` twice is an error</span><br><span class="line">  setImmediate(done);</span><br><span class="line">  setImmediate(done);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>运行上述测试将会得到下面的错误信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">lenovo@LAPTOP-QGCH84J8 MINGW64 /e/workSpace/study/1-单元测试/test</span><br><span class="line">$ npm test</span><br><span class="line"></span><br><span class="line">&gt; @ test E:\workSpace\study\1-单元测试\test</span><br><span class="line">&gt; mocha</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  √ double done</span><br><span class="line">  1) double done</span><br><span class="line">  add函数的测试</span><br><span class="line">    √ 3加4应该等于7</span><br><span class="line"></span><br><span class="line">  Array</span><br><span class="line">    #indexOf()</span><br><span class="line">      √ should return -1 when the value is not present</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  3 passing (9ms)</span><br><span class="line">  1 failing</span><br><span class="line"></span><br><span class="line">  1) double done:</span><br><span class="line">     Error: done() called multiple times</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">npm ERR! Test failed.  See above for more details.</span><br></pre></td></tr></table></figure><h1 id="ASSERTIONS-断言"><a href="#ASSERTIONS-断言" class="headerlink" title="ASSERTIONS(断言)"></a>ASSERTIONS(断言)</h1><p>mocha 允许你使用任意你喜欢的断言库，在上面的 add 例子中我们使用了 node.js 内置的 assert 模块作为断言。如果抛出一个错误，它就能够运行。这意味着你能够使用下面的这些仓库，比如：</p><p><a href="https://github.com/shouldjs/should.js" target="_blank" rel="noopener">should.js</a></p><p><a href="https://github.com/Automattic/expect.js" target="_blank" rel="noopener">expect.js</a></p><p><a href="https://www.chaijs.com/" target="_blank" rel="noopener">chai</a></p><p><a href="https://github.com/tj/better-assert" target="_blank" rel="noopener">better-assert</a></p><p><a href="http://unexpected.js.org/" target="_blank" rel="noopener">unexpect</a></p><h1 id="异步测试"><a href="#异步测试" class="headerlink" title="异步测试"></a>异步测试</h1><p>使用 mocha 测试异步代码是再简单不过了。只需要在测试完成的时候调用一下回调函数即可。通过添加一个回调函数(通常命名为 done)给 it()方法，Mocha 就会知道，它应该等这个函数被调用的时候才能完成测试。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">describe(&apos;User&apos;, function() &#123;</span><br><span class="line">    describe(&apos;#save()&apos;, function() &#123;</span><br><span class="line">        it(&apos;should save without error&apos;, function() &#123;</span><br><span class="line">            var user = new User(&apos;Luna&apos;)</span><br><span class="line">            user.save(function(err) &#123;</span><br><span class="line">                if(err) done(err);</span><br><span class="line">                else done()</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>也可以让事情变得更简单，因为 done()函数接收一个 err，所以，我们可以直接按照下面的使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">describe(&apos;User&apos;, function() &#123;</span><br><span class="line">    describe(&apos;#save()&apos;, function() &#123;</span><br><span class="line">        it(&apos;should save without error&apos;, function(done) &#123;</span><br><span class="line">            var user = new User(&apos;Luna&apos;)</span><br><span class="line">            user.save(done)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="promise-测试"><a href="#promise-测试" class="headerlink" title="promise 测试"></a>promise 测试</h1><p>同时，除了使用 done()回调函数，你也可以返回一个 Promise。这种方式对于测试那些返回 promies 的方法是实用的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">beforeEach(function() &#123;</span><br><span class="line">  return db.clear()</span><br><span class="line">    .then(function() &#123;</span><br><span class="line">      return db.save([tobi, loki, jane]);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">describe(&apos;#find()&apos;, function() &#123;</span><br><span class="line">  it(&apos;respond with matching records&apos;, function() &#123;</span><br><span class="line">    return db.find(&#123; type: &apos;User&apos; &#125;).should.eventually.have.length(3);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h1><p>mocha 提供 4 种钩子函数：before()、after()、beforeEach()、afterEach()，这些钩子函数可以用来在用例集/用例函数开始执行之前/结束执行之后，进行一些环境准备或者环境清理的工作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">describe(&apos;hooks&apos;, function() &#123;</span><br><span class="line"></span><br><span class="line">  before(function() &#123;</span><br><span class="line">    // runs before all tests in this block</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  after(function() &#123;</span><br><span class="line">    // runs after all tests in this block</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  beforeEach(function() &#123;</span><br><span class="line">    // runs before each test in this block</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  afterEach(function() &#123;</span><br><span class="line">    // runs after each test in this block</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  // test cases</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><hr><p><strong><em>愿圣光与你同在！</em></strong></p><p>如本文有任何问题欢迎指正，谢谢！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;自出道以来一直想写个单元测试来的，但是一直都在想，终于今天开始写了，也算迈出了小小的一步。&lt;/p&gt;
&lt;h1 id=&quot;INSTALLATION-安装&quot;&gt;&lt;a href=&quot;#INSTALLATION-安装&quot; class=&quot;headerlink&quot; title=&quot;INSTALLAT
      
    
    </summary>
    
    
    
      <category term="mocha, TDD , 测试" scheme="http://yoursite.com/tags/mocha-TDD-%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>github+hexo搭建个人博客</title>
    <link href="http://yoursite.com/2018/10/26/github+hexo/"/>
    <id>http://yoursite.com/2018/10/26/github+hexo/</id>
    <published>2018-10-26T10:16:54.000Z</published>
    <updated>2019-12-24T09:45:36.545Z</updated>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=32192436&auto=0&height=66"></iframe><p>以前就想折腾这个 github 的博客，怎奈各种加班没有时间，最近比较闲就拿出来折腾了，其实人家还是很兴奋的了啦，折腾出来的时候还是很有成就感的，终于有了自己的博客了，还是自己一手搭建的，虽然其中也踩了不少的坑，傻笑+手舞足蹈，你没有看错，嗯，就是一个疯子。然后这个网易云音乐就舍不得删了，哈哈，至于网易云音乐的外链播放器怎么生成，自己百度吧，哈哈哈。</p><p>博客的创建与发布</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo new &apos;文件名&apos; //会在source/_posts创建一个文件名.md文件</span><br><span class="line"></span><br><span class="line">hexo s  // 本地预览效果, https://localhost:4000</span><br><span class="line"></span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d //发布到 github</span><br></pre></td></tr></table></figure><p><a href="https://13hua.github.io/" target="_blank" rel="noopener">博客主页地址</a></p><h4 id="Project-setup"><a href="#Project-setup" class="headerlink" title="Project setup"></a>Project setup</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">hexo g //生成</span><br><span class="line">hexo s //启动服务 开启本地预览服务 http://localhost:4000</span><br></pre></td></tr></table></figure><h2 id="常用hexo命令"><a href="#常用hexo命令" class="headerlink" title="常用hexo命令"></a>常用hexo命令</h2><p>####常见命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;postName&quot; # 新建文章</span><br><span class="line">hexo new page &quot;postName&quot; # 新建页面</span><br><span class="line">hexo generate # 生成静态页面至public目录</span><br><span class="line">hexo server # 开启预览访问段港口（默认端口4000）</span><br><span class="line">hexo deploy # 部署到github</span><br><span class="line">hexo help # 查看帮助</span><br><span class="line">hexo version # 查看hexo的版本</span><br></pre></td></tr></table></figure></p><h4 id="缩写"><a href="#缩写" class="headerlink" title="缩写"></a>缩写</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo n === hexo new</span><br><span class="line">hexo g === hexo generate</span><br><span class="line">hexo s === hexo server</span><br><span class="line">hexo d === hexo deploy</span><br></pre></td></tr></table></figure><h4 id="组合命令"><a href="#组合命令" class="headerlink" title="组合命令"></a>组合命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo s -g #生成本地预览</span><br><span class="line">hexo d -g #生成并上传</span><br></pre></td></tr></table></figure><p>主线是按照 <a href="https://www.jianshu.com/p/a52b68794a6b" target="_blank" rel="noopener">hexo 创建个人博客（附加插入音乐、分享、评论、标签页、搜索）</a>这个教程来做的，多余的话不说了，只做一些补充。</p><h3 id="部分补充说明"><a href="#部分补充说明" class="headerlink" title="部分补充说明"></a>部分补充说明</h3><ol><li><p>编辑器我使用的是 vs code，很好用。</p></li><li><p>这份简书博文中所说的评论系统“多说”已经挂了，参考 <a href="https://blog.csdn.net/weixin_41196185/article/details/79178780" target="_blank" rel="noopener">hexo+github 打造个人博客系列之评论系统</a> 这篇博文，我选用了 github 的 gitment，分享用 jiathis，百度，但是这两种都是 http 的，不支持 https，我就放过去了，没有再折腾。</p></li><li><p>搜索这一部分<a href="http://theme-next.iissnan.com/third-party-services.html#algolia-search" target="_blank" rel="noopener">next 主题官网 Algolia 搜索</a>也有介绍,我用的是 local search，还不错的样子<img src="/2018/10/26/github+hexo/search-1.png" alt="搜索效果图" title="搜索效果图"></p></li><li><p>有了这些经验，其他的配置都可以根据<a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">next 主题官网</a>自己配置了</p></li><li><p><a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">next 主题官网</a></p></li><li><p><a href="https://www.jianshu.com/p/8d28027fec76" target="_blank" rel="noopener">文章图片的插入</a></p></li></ol><h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><ol><li><p>在本地预览 （hexo s） 的时候是成功的，但是部署到 github 上的时候，样式没有加载出来。</p><p>通过控制台查看样式文件报 404，是因为 url 地址不对。需要修改_config.yml 文件中的 url 地址和根目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># URL</span><br><span class="line">## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;</span><br><span class="line">url: https://banjingwei.github.io/ban.github.io</span><br><span class="line">root: /ban.github.io/</span><br><span class="line">permalink: :year/:month/:day/:title/</span><br><span class="line">permalink_defaults:</span><br></pre></td></tr></table></figure><p>url 是 github pages 给我们分配的网址</p></li><li><p>gitment 评论 Error：Not Found<br>通常是 repo 或者 owner 配置不对，owner 是申请时候填的,下面是我的 repo 配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">github_repo: 13hua.github.io, # MUST HAVE, The repo you use to store Gitment comments</span><br></pre></td></tr></table></figure></li><li><p>gitment 评论初始化的时候弹出 Error：validation failed。</p><p>issue 的标签 label 有长度限制！labels 的最大长度限制是 50 个字符。</p><p>修改 next/layout/_third-party/comments/gitment.swig</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id: window.location.pathname</span><br></pre></td></tr></table></figure><p>找到上面一行，将 id 的值修改成如下即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id: &apos;&#123;&#123; page.title &#125;&#125;&apos;</span><br></pre></td></tr></table></figure><p>但是，title 也有可能超过 50 个字符怎么办呢？修改成日期不就可以了么，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id: &apos;&#123;&#123; page.date &#125;&#125;&apos;</span><br></pre></td></tr></table></figure><ol start="4"><li>赞赏功能的配置，图片放在 next/source/images 下，在<font color="#9954BB">主题配置文件</font>中做出如下配置，其中 13hua.github.io 是我的 blog 的 repo，改成你自己的即可。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">reward_comment: 坚持原创技术分享，您的支持将鼓励我继续创作！</span><br><span class="line">wechatpay: /13hua.github.io/images/wechatpay.jpg</span><br><span class="line">alipay: /13hua.github.io/images/alipay.jpg</span><br></pre></td></tr></table></figure><blockquote><p>致谢：</p></blockquote><ol><li><p><a href="https://www.jianshu.com/p/a52b68794a6b" target="_blank" rel="noopener">hexo 创建个人博客（附加插入音乐、分享、评论、标签页、搜索）</a></p></li><li><p><a href="https://blog.csdn.net/weixin_41196185/article/details/79178780" target="_blank" rel="noopener">hexo+github 打造个人博客系列之评论系统</a></p></li><li><p><a href="https://segmentfault.com/a/1190000009544924" target="_blank" rel="noopener">hexo 的 next 主题个性化配置教程</a></p></li><li><p><a href="https://www.jianshu.com/p/8d28027fec76" target="_blank" rel="noopener">文章图片的插入</a></p></li></ol><hr><p><strong><em>愿圣光与你同在！</em></strong></p><p>如本文有任何问题欢迎指正，谢谢！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=
      
    
    </summary>
    
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
</feed>
