<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>十三画的博客</title>
  
  <subtitle>人各有价，千万不要活得太便宜</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-01-06T07:27:44.945Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>十三画</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>TCP/IP协议</title>
    <link href="http://yoursite.com/2019/12/24/TCP-IP%E5%8D%8F%E8%AE%AE/"/>
    <id>http://yoursite.com/2019/12/24/TCP-IP%E5%8D%8F%E8%AE%AE/</id>
    <published>2019-12-24T10:20:01.000Z</published>
    <updated>2020-01-06T07:27:44.945Z</updated>
    
    <content type="html"><![CDATA[<h2 id="网络基础TCP-IP"><a href="#网络基础TCP-IP" class="headerlink" title="网络基础TCP/IP"></a>网络基础TCP/IP</h2><p>为了理解http，我们有必要事先了解一下TCP/IP协议族。<br>通常使用的网络（包括互联网）是在TCP/IP的基础上运作的，而HTTP属于它的一个子集。</p><p>计算机与网络设备要相互通信，双方就必须基于相同的方法。如，如何探测到通信目标、有哪一边先发起通信、使用哪种语言进行通信、怎样结束通信等规则都需要事先确定。不同的硬件、操作系统之间的通信，所有的这一切都需要一种规则。而我们把这种规则称为<code>协议(protocol)</code>。把与互联网相关联的协议集合起来总称为<code>TCP/IP</code>。也有一种说法认为TCP/IP是指TCP和IP这两种协议，还有一种说法认为TCP/IP是在IP协议的通信过程中，使用到的协议族的总称。</p><h3 id="TCP-IP的分层管理"><a href="#TCP-IP的分层管理" class="headerlink" title="TCP/IP的分层管理"></a>TCP/IP的分层管理</h3><p>TCP/IP协议族按层次分别分为4层：<code>应用层、传输层、网络层、数据链路层</code>。</p><p>类似于代码的模块化，无疑TCP/IP协议族分层是很有好处的，各层各司其职互不干扰，如果需要更换其中的某一层只需换掉这一层即可。</p><p>各层作用如下：</p><ol><li><p>应用层<br>应用层决定了向用户提供应用服务时的通信活动。TCP/IP协议族内预存了各类通用的应用服务。比如：FTP(File Transfer Protocol 文件传输协议)和DNS(Domain Name System 域名系统)就是其中的两类。<code>HTTP协议也处于该层</code>。</p></li><li><p>传输层<br>传输层对上层应用层提供处于网络连接中的两台计算机之间的数据传输。</p></li></ol><p>在传输层有两个性质不同的协议：TCP(Transmission Control Protocol 传输控制协议)和UDP(User Data Protocol 用户数据报协议)</p><ol start="3"><li><p>网络层<br>网络层又名网络互连层。网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数据单位。该层规定了通过怎样的路径（所谓的传输路线）到达对方计算机，并把数据包传送给对方。</p></li><li><p>数据链路层<br>数据链路层又名链路层、网络接口层。用来处理网路的硬件部分。包括控制操作系统、硬件的设备驱动、NIC(Network Interface Card 网络适配器即 网卡)，及光纤等物理可见部分（还包括连接等一切传输媒介）。硬件上的范畴均在数据链路层的作用范围之内。</p></li></ol><h2 id="TCP-IP通信传输"><a href="#TCP-IP通信传输" class="headerlink" title="TCP/IP通信传输"></a>TCP/IP通信传输</h2><p><img src="/2019/12/24/TCP-IP协议/img-1.png" alt="TCP-IP协议图" title="TCP-IP协议图"></p><p>发送端从应用层往下走，接收端从数据链路层往上走。用http举例来说明：</p><ul><li>首先，作为发送端的客户端在应用层（http协议）发出一个想看某个web页面的http请求</li><li>接着，为了传输方便，在传输层（TCP协议）把从应用层处收到的数据（HTTP请求报文）进行分割，并在各个报文上打上标记序号及端口号后转发给网络层。</li><li>在网络层（IP协议）。增加作为通信目的地的MAC（Media Access Control Address 物理地址，一般是不变的）地址后转发给链路层。这样一来发往网络的通信请求就准备齐全了。</li><li>接收端的服务器在链路层接收到数据，按序往上层发送，一直到应用层。当传输到应用层，才能算真正接收到由客户端发送过来的HTTP请求。</li></ul><p>发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息。反之，按接收端在层与层传输数据时，每经过一层时会把对应的首部消去。</p><p>这种把数据信息包装起来的做法称为<code>封装（encapsulate）</code></p><p>概念解释：</p><ul><li>IP是一种协议，一种把各种数据包传送给对方的协议。</li><li>IP地址是指节点被分配到的地址，IP地址可以和MAC地址进行配对，IP地址可变换</li><li>MAC地址是指网卡所属的固定地址，MAC地址基本上不会更改。</li></ul><h2 id="ARP协议凭借MAC地址进行通信"><a href="#ARP协议凭借MAC地址进行通信" class="headerlink" title="ARP协议凭借MAC地址进行通信"></a>ARP协议凭借MAC地址进行通信</h2><p>IP之间的通信依赖MAC地址。在网络上，通信双方在同一局域网（LAN）内的情况是很少的，通常是经过多台计算机和网络设备中转才能连接到对方。而在进行中转时，会利用下一站中转设备的MAC地址来搜索下一个中转目标。这时会采用ARP协议（Address Resolution Protocol）。<code>ARP是一种用以解析地址的协议，根据通信方的IP地址就可以反查出对应的MAC地址。</code></p><hr><p><strong><em>愿圣光与你同在！</em></strong></p><p>如本文有任何问题欢迎指正，谢谢！</p><blockquote><p>致谢：</p></blockquote><p>《图解HTTP》[日] 上野 宣 著 于均良 译 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;网络基础TCP-IP&quot;&gt;&lt;a href=&quot;#网络基础TCP-IP&quot; class=&quot;headerlink&quot; title=&quot;网络基础TCP/IP&quot;&gt;&lt;/a&gt;网络基础TCP/IP&lt;/h2&gt;&lt;p&gt;为了理解http，我们有必要事先了解一下TCP/IP协议族。&lt;br&gt;通常使用
      
    
    </summary>
    
    
    
      <category term="TCP/IP协议" scheme="http://yoursite.com/tags/TCP-IP%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>canvas优化</title>
    <link href="http://yoursite.com/2019/12/24/canvas%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2019/12/24/canvas%E4%BC%98%E5%8C%96/</id>
    <published>2019-12-24T10:14:49.000Z</published>
    <updated>2020-01-06T07:28:38.826Z</updated>
    
    <content type="html"><![CDATA[<p>关于Canvas的优化，主要从一下几个方面入手</p><ul><li>离屏渲染canvas上预渲染相似的图形或重复的对象</li><li>避免浮点数的坐标点，用整数取而代之</li><li>避免在用drawImage时缩放图像</li><li>使用多层画布去画一个重复的场景</li><li>用css设置大的背景图</li><li>用transforms特性缩放画布</li><li>关闭透明度</li><li>将画布的函数调用集合到一起（例如，画一条折线，而不要画多条分开的直线）</li><li>避免不必要的画布状态改变</li><li>渲染画布中的不同点，而非整个新状态</li><li>尽可能避免shwdowBlur特性</li><li>尽可能避免text rendering</li><li>使用不同的办法清除画布（clearReact()vs.fillRect()vs.调整canvas大小）</li><li>有动画，请使用window.requestAnimationFrame()而非windowsetInterval()</li><li>请谨慎使用大型物理库<br>…</li></ul><p>下面我们来详细说一说Canvas性能优化的事儿。<br>canvas是HTML5出的一个标签，用js控制绘制图形。canvas标签一定要有width和height，不能在style中定义width和height，否则会出现变形、缩放等一系列问题。</p><p>先来了解一下canvas的渲染</p><p><code>canvas上下文是状态机</code>canvas API 都在其上下文对象context<br>上抵用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const context = canvas.getContext(&apos;2d&apos;);</span><br></pre></td></tr></table></figure></p><h3 id="context是一个状态机。"><a href="#context是一个状态机。" class="headerlink" title="context是一个状态机。"></a>context是一个状态机。</h3><p>你可以改变context的若干状态，而几乎所有的渲染操作，最终的效果与context本身的状态有关系。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">context.lineWidth = 5;</span><br><span class="line">context.strokeStyle=&quot;f00&quot;</span><br><span class="line">context.strokeRect(100,100,200,200)</span><br></pre></td></tr></table></figure><p>context.lineWidth 的赋值开销要远远大于普通对象赋值的开销。context不是一个普通的对象，当你调用了context.lineWidth = 5 时，浏览器会需要立刻去做一些事情，这样你下次调用诸如stroke或strokeRect等API时，画出来的正好是5px宽了。（不难想象，这也是一种优化，否则，这些事情就要等到下次stroke之前做，更加会影响性能）。</p><p>下面我们来一组实验，将如下代码执行1000,000次：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 10^6times</span><br><span class="line">somePlainObject.lineWidth = 5;  // 3ms </span><br><span class="line">context.lineWidth = 5;  // 40ms</span><br><span class="line">context.lineWidth = &apos;Hello World!&apos;; // 140ms</span><br><span class="line">context.lineWidth = &#123;&#125;; // 600ms</span><br></pre></td></tr></table></figure><p>事实证明：对一个普通对象的赋值只消耗了3ms，而对<code>context</code>的赋值则消耗了40ms。值得注意的是，<code>如果你的赋值是非法的，浏览器还需要一些额外的时间来处理非法的输入</code>，正如最后两种情形所示，消耗了140ms 甚至更多。</p><p>对<code>context</code>而言，对不同的属性的赋值开销也是不同的。lineWidth只是开销较小的一类。我们整理了一些其他属性赋值的开销，如下所示：</p><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">开销</th><th style="text-align:left">开销（非法赋值）</th></tr></thead><tbody><tr><td style="text-align:left">line[Width/Join/Cap]</td><td style="text-align:left">40+</td><td style="text-align:left">100+</td></tr><tr><td style="text-align:left">[fill/stroke]Style</td><td style="text-align:left">100+</td><td style="text-align:left">200+</td></tr><tr><td style="text-align:left">font</td><td style="text-align:left">1000+</td><td style="text-align:left">1000+</td></tr><tr><td style="text-align:left">text[Align/Baseline]</td><td style="text-align:left">60+</td><td style="text-align:left">100+</td></tr><tr><td style="text-align:left">shadow[Blur/OffsetX]</td><td style="text-align:left">40+</td><td style="text-align:left">100+</td></tr><tr><td style="text-align:left">shadowColor</td><td style="text-align:left">280+</td><td style="text-align:left">400+</td></tr></tbody></table><p>看到这里你应该明白为什么说要尽量减少shwdowBlur、font、text了吧。</p><h3 id="canvas的分层"><a href="#canvas的分层" class="headerlink" title="canvas的分层"></a>canvas的分层</h3><p>使用canvas作动画，在比较复杂的情况下分层是非常有必要的。比如背景的变化很少甚至基本不变，而角色一直在16ms的变化。这种时候就需要将背景和主角分层了。类似于背景始终不变的这种场景可以通过css来设置背景，对于变化频率不高的背景可以使用canvas分层渲染。</p><p>对于canvas分层我们所需要做的，仅仅只是生成多个Canvas实例，把它们重叠放置，每个canvas使用不同的z-index来定义堆叠的次序。然后仅在需要绘制该层的时候（也许是‘永不’）进行重绘。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;canvas id=&quot;clock&quot; width=&quot;400&quot; height=&quot;400&quot;&gt;您的浏览器居然不支持canvas？赶紧换一个吧&lt;/canvas&gt;</span><br><span class="line">&lt;canvas id=&quot;timer&quot; width=&quot;500&quot; height=&quot;400&quot;&gt;您的浏览器居然不支持canvas？赶紧换一个吧&lt;/canvas&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">const canvas1 = document.getElementById(&apos;clock&apos;)</span><br><span class="line">const ctx1 = canvas.getContext(&apos;2d&apos;)</span><br><span class="line"></span><br><span class="line">const canvas2 = document.getElementById(&apos;timer&apos;)</span><br><span class="line">const ctx2 = canvas.getContext(&apos;2d&apos;)</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><code>注意: 堆叠在上方的canvas中的内容会覆盖住下方的canvas中的内容</code></p><h3 id="绘制图像"><a href="#绘制图像" class="headerlink" title="绘制图像"></a>绘制图像</h3><p>我们来说一说drawImage这个API，使用格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ctx.drawImage(image, dx, dy);</span><br><span class="line">ctx.drawImage(image, dx, dy, dWidth, dHeight);</span><br><span class="line">ctx.drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);</span><br></pre></td></tr></table></figure><p><img src="/2019/12/24/canvas优化/Canvas_drawimage.jpg" alt="drawImage图" title="drawImage图"></p><p>— 我们尝试绘制10000次一块320x180的矩形区域，如果数据源是一张320x180的图片,花费了40ms,而如果数据源是一张800x800图片中裁剪出来的320x180的区域，需要花费70ms。我们发现比起数据源是一张较大的图片（我们只是把数据扣下来了而已）的情形，数据源是一张和绘制区域尺寸相仿的情形开销要小一些。可以认为两者相差的开销是‘裁剪’这一个操作的开销。</p><h3 id="离屏渲染"><a href="#离屏渲染" class="headerlink" title="离屏渲染"></a>离屏渲染</h3><p>我们做了一个实验，绘制一张320x180的图片10000次，当每次绘制在canvas内部是，消耗了40ms，而当每次都绘制在canvas外时，仅消耗了8ms。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 在离屏 canvas 上绘制</span><br><span class="line">var canvasOffscreen = document.createElement(&apos;canvas&apos;);</span><br><span class="line">canvasOffscreen.width = dw;</span><br><span class="line">canvasOffscreen.height = dh;</span><br><span class="line">canvasOffscreen.getContext(&apos;2d&apos;).drawImage(image, sx, sy, sw, sh, dx, dy, dw, dh);</span><br><span class="line"></span><br><span class="line">// 在绘制每一帧的时候，绘制这个图形</span><br><span class="line">context.drawImage(canvasOffscreen, x, y);</span><br></pre></td></tr></table></figure><p>我曾经遇到过一个场景，有4000个点，每个点16ms刷新一次，我每一次在canvas内重新绘制的方法渲染的话 不到半个小时浏览器就直接奔溃了。后来偶然之间在网上看到有人使用了离屏渲染的技巧，于是我用了跟上面这段代码很相似的方法，就是先在canvas之外生成一个canvas2实例，在这个canvas2对象上绘制一个点，之后每一次都在canvas对象上使用drawImage的方式绘制4000多个点，结果性能大大提高，浏览器奔溃什么的根本不存在的。</p><p>CSS transforms 特性由于调用GPU，因此更快捷。最好的情况是，不要将小画布放大，而是去将大画布缩小。</p><p>调用window.requestAnimationFrame()时，浏览器会自动进行优化。window.requestAnimationFrame() 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行</p><p>当你准备更新动画时你应该调用此方法。这将使浏览器在下一次重绘之前调用你传入给该方法的动画函数(即你的回调函数)。回调函数执行次数通常是每秒60次，但在大多数遵循W3C建议的浏览器中，回调函数执行次数通常与浏览器屏幕刷新次数相匹配。为了提高性能和电池寿命，因此在大多数浏览器里，当requestAnimationFrame() 运行在后台标签页或者隐藏的<iframe> 里时，requestAnimationFrame() 会被暂停调用以提升性能和电池寿命。</iframe></p><p>回调函数会被传入DOMHighResTimeStamp参数，DOMHighResTimeStamp指示当前被 requestAnimationFrame() 排序的回调函数被触发的时间。在同一个帧中的多个回调函数，它们每一个都会接受到一个相同的时间戳，即使在计算上一个回调函数的工作负载期间已经消耗了一些时间。该时间戳是一个十进制数，单位毫秒，最小精度为1ms(1000μs)。</p><hr><p><strong><em>愿圣光与你同在！</em></strong></p><p>如本文有任何问题欢迎指正，谢谢！</p><blockquote><p>致谢：</p></blockquote><ol><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial/Optimizing_canvas" target="_blank" rel="noopener">MDN：canvas 性能</a></p></li><li><p><a href="https://fed.taobao.org/blog/taofed/do71ct/canvas-performance/?spm=taofed.blogs.blog-list.2.6b365ac8l8NLf9" target="_blank" rel="noopener">Canvas 最佳实践（性能篇）</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;关于Canvas的优化，主要从一下几个方面入手&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;离屏渲染canvas上预渲染相似的图形或重复的对象&lt;/li&gt;
&lt;li&gt;避免浮点数的坐标点，用整数取而代之&lt;/li&gt;
&lt;li&gt;避免在用drawImage时缩放图像&lt;/li&gt;
&lt;li&gt;使用多层画布去画一个
      
    
    </summary>
    
    
    
      <category term="canvas" scheme="http://yoursite.com/tags/canvas/"/>
    
  </entry>
  
  <entry>
    <title>mpvue微信小程序踩坑笔记(一)</title>
    <link href="http://yoursite.com/2019/01/19/wx-study-1/"/>
    <id>http://yoursite.com/2019/01/19/wx-study-1/</id>
    <published>2019-01-19T06:22:47.000Z</published>
    <updated>2019-12-24T10:11:46.525Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/13hua" target="_blank" rel="noopener">demo源码</a></p><p>mpvue可以使用vue的基本语法来开发小程序，可以使用vux，flyio等来辅助开发，方便快捷高效开发。当然这其中还有诸多限制。<br>官方文档指出的问题就不一一罗列了，不清楚的童鞋请看这里 mpvue官方文档</p><p>另外看到了一份写的还不错的<a href="https://github.com/noahlam/articles/blob/master/%E7%BE%8E%E5%9B%A2%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6mpvue%E8%B9%B2%E5%9D%91%E6%8C%87%E5%8D%97.md" target="_blank" rel="noopener">踩坑指南</a> ，共勉</p><p>下面来说说我踩的坑。</p><h2 id="一、-swiper组件的问题"><a href="#一、-swiper组件的问题" class="headerlink" title="一、 swiper组件的问题"></a>一、 swiper组件的问题</h2><h4 id="1-swiper组件自适应高度问题"><a href="#1-swiper组件自适应高度问题" class="headerlink" title="1. swiper组件自适应高度问题"></a>1. swiper组件自适应高度问题</h4><p>解决思路是：获取屏幕宽度，获取图片的宽高，然后等比设置当前屏幕宽度下swiper的高度。因为load事件只在图片第一次加载的时候执行，所以取所有图片高度的最大值即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;swiper :current=&quot;currSwiperItem&quot; skip-hidden-item-layout=&quot;true&quot; @change=&quot;switchItem(&apos;switchItem&apos;,$event)&quot; :style=&quot;swiperImgH&quot;&gt;</span><br><span class="line">  &lt;swiper-item v-for=&quot;(list,index) in swiperList&quot; :key=&quot;index&quot;&gt;</span><br><span class="line">    &lt;img  class=&quot;img&quot; :src=&quot;list.imgPath&quot; @load=&quot;calcImgH&quot; mode=&quot;widthFix&quot; alt=&quot;&quot;&gt;</span><br><span class="line">  &lt;/swiper-item&gt;</span><br><span class="line">&lt;/swiper&gt;　</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">  * 动态计算swiper图片的高度</span><br><span class="line">  */</span><br><span class="line">calcImgH: async function (e) &#123;</span><br><span class="line">  let winWidth = wx.getSystemInfoSync().windowWidth; // 获取当前屏幕的宽度</span><br><span class="line">  let imgH = e.mp.detail.height; // 图片高度</span><br><span class="line">  let imgW = e.mp.detail.width;</span><br><span class="line">  if (imgH &gt; this.curImgH) &#123;</span><br><span class="line">    this.curImgH = imgH;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  this.swiperImgH = `height:$&#123;winWidth * this.curImgH / imgW&#125;px`;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p><h4 id="2-swiper组件的current一定要写，如果不写就会出现只显示两张图片，从第三张开始高度均为0-如果出现这种问题，请优先查看是否定义了current"><a href="#2-swiper组件的current一定要写，如果不写就会出现只显示两张图片，从第三张开始高度均为0-如果出现这种问题，请优先查看是否定义了current" class="headerlink" title="2. swiper组件的current一定要写，如果不写就会出现只显示两张图片，从第三张开始高度均为0.如果出现这种问题，请优先查看是否定义了current"></a>2. swiper组件的current一定要写，如果不写就会出现只显示两张图片，从第三张开始高度均为0.如果出现这种问题，请优先查看是否定义了current</h4><h2 id="二、v-show不能使用，请使用v-if，具体原因应该是mpvue的问题，可能是编译的时候出了问题没有编译成wx：show"><a href="#二、v-show不能使用，请使用v-if，具体原因应该是mpvue的问题，可能是编译的时候出了问题没有编译成wx：show" class="headerlink" title="二、v-show不能使用，请使用v-if，具体原因应该是mpvue的问题，可能是编译的时候出了问题没有编译成wx：show"></a>二、<code>v-show</code>不能使用，请使用<code>v-if</code>，具体原因应该是<code>mpvue</code>的问题，可能是编译的时候出了问题没有编译成<code>wx：show</code></h2><h2 id="三、canvas保存图片的时候显示的是上一张图片，这里需要做重置处理，这个不是mpvue的问题"><a href="#三、canvas保存图片的时候显示的是上一张图片，这里需要做重置处理，这个不是mpvue的问题" class="headerlink" title="三、canvas保存图片的时候显示的是上一张图片，这里需要做重置处理，这个不是mpvue的问题"></a>三、canvas保存图片的时候显示的是上一张图片，这里需要做重置处理，这个不是mpvue的问题</h2><h2 id="四、关于文件命名问题"><a href="#四、关于文件命名问题" class="headerlink" title="四、关于文件命名问题"></a>四、关于文件命名问题</h2><p>例如：我想把 <code>/pages/list/index.vue</code> 中的js代码提出来 单独放在 <code>/pageslist/index.js</code>中，这个时候这个<code>index.js</code>文件命名就有问题了，在微信开发工具中会提示找不到<code>/pages/list/main.wxml</code> 文件，我想可能是因为<code>list</code>下出现了两个<code>index</code>文件<code>mpvue</code>不知道编译哪一个，所以才出现了问题的吧，把<code>js</code>文件改成除了<code>index</code>外的任何名字就好了。</p><h2 id="五、vux的使用，在utils等纯js文件中使用store-在vue中我们会使用引入文件的方式使用，没有任何问题，"><a href="#五、vux的使用，在utils等纯js文件中使用store-在vue中我们会使用引入文件的方式使用，没有任何问题，" class="headerlink" title="五、vux的使用，在utils等纯js文件中使用store,在vue中我们会使用引入文件的方式使用，没有任何问题，"></a>五、vux的使用，在utils等纯js文件中使用store,在vue中我们会使用引入文件的方式使用，没有任何问题，</h2><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import store from &apos;./store.js&apos; </span><br><span class="line"> </span><br><span class="line">console.log(store.status);</span><br></pre></td></tr></table></figure><p>但是在<code>mpvue</code>中这样直接引入<code>store</code>使用是有问题的,这样写不会报错，在<code>mpvue</code>中这里的<code>store</code>和<code>vue</code>实例中的<code>this.$store</code>不是同一个实例，即 这里的<code>store.status !== this.$store.status</code>。也就是说修改<code>store.status</code>的值，<code>this.$store.status</code>并不会做任何的改变，他们俩没有关系。</p><h2 id="六、canvas-问题"><a href="#六、canvas-问题" class="headerlink" title="六、canvas 问题"></a>六、canvas 问题</h2><p>因为<code>canvas</code>使用的是原生组件，<code>z-index</code>并不会影响它的层级，永远是在最上层的，如果需要做弹窗遮罩就需要使用 <code>cover-view</code> 或者<code>cover-image</code> ，这里需要注意的是<code>cover-view</code> 或者<code>cover-image</code>必须要写在<code>canvas</code>上下文的后面，如果写在前面还是一样无法遮住。</p><h2 id="七、scroll-view-上拉加载下拉刷新"><a href="#七、scroll-view-上拉加载下拉刷新" class="headerlink" title="七、scroll-view 上拉加载下拉刷新"></a>七、scroll-view 上拉加载下拉刷新</h2><p>在<code>@touchend=&quot;scrollTouchEnd&quot;</code> 事件中 对满足条件的 <code>scroll-top</code> 赋值之后并没有 并没有页面做出实质对的改变，因为对同一个值做相同的复制操作的时候<code>mpvue</code>并没有执行这个赋值动作，解决方法是再赋一个不同的值，这样就会做出改变了，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">scrollTouchEnd() &#123;</span><br><span class="line">  console.log(&apos;scrollTouchEnd&apos;);</span><br><span class="line"></span><br><span class="line">  if (this.scrollingTop &lt; 80) &#123;</span><br><span class="line">    console.log(&apos;下拉刷新&apos;);</span><br><span class="line">    this.refresh();</span><br><span class="line">    this.scrolledTop = 0;</span><br><span class="line">    this.scrolledTop = 80;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (this.scrollHeight - this.scrollingTop - this.scrollWrapHeight &lt;= 80) &#123;</span><br><span class="line">    console.log(&apos;上拉加载&apos;);</span><br><span class="line">    this.loadMore();</span><br><span class="line">    this.scrolledTop = this.scrollHeight - this.scrollWrapHeight;</span><br><span class="line">    this.scrolledTop = this.scrollHeight - this.scrollWrapHeight - 80;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong><em>愿圣光与你同在！</em></strong></p><p>如本文有任何问题欢迎指正，谢谢！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://github.com/13hua&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;demo源码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;mpvue可以使用vue的基本语法来开发小程序，可以使用vux，flyio等来辅助开发，方便快捷高效开发。
      
    
    </summary>
    
    
    
      <category term="mpvue" scheme="http://yoursite.com/tags/mpvue/"/>
    
  </entry>
  
  <entry>
    <title>关于单元测试mocha的学习笔记</title>
    <link href="http://yoursite.com/2018/11/03/mocha/"/>
    <id>http://yoursite.com/2018/11/03/mocha/</id>
    <published>2018-11-03T14:42:49.000Z</published>
    <updated>2019-12-24T09:45:49.705Z</updated>
    
    <content type="html"><![CDATA[<p>自出道以来一直想写个单元测试来的，但是一直都在想，终于今天开始写了，也算迈出了小小的一步。</p><h1 id="INSTALLATION-安装"><a href="#INSTALLATION-安装" class="headerlink" title="INSTALLATION(安装)"></a>INSTALLATION(安装)</h1><p>全局安装，(非必需，虽然很多文章都要求全局安装，但是廖雪峰大大建议尽量不要全局安装，因为全局模块会影响到所有 Node.js 的工程)</p><p><code>npm install --global mocha</code></p><p>项目局部安装</p><p><code>npm install --save-dev mocha</code></p><p>如果 npm 网速比较慢，建议使用 yarn。</p><h1 id="GETTING-STARTED-起步"><a href="#GETTING-STARTED-起步" class="headerlink" title="GETTING STARTED(起步)"></a>GETTING STARTED(起步)</h1><p>新建项目，并在项目中安装 mocha。新建一个 test 文件夹，所有的 test 文件就都放在这个文件夹下，mocha 默认会执行 test 目录下的所有测试，不要去改变默认目录。</p><p>在 test.js 中写下如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var assert = require(&apos;assert&apos;);</span><br><span class="line">describe(&apos;Array&apos;, function() &#123;</span><br><span class="line">  describe(&apos;#indexOf()&apos;, function() &#123;</span><br><span class="line">    it(&apos;should return -1 when the value is not present&apos;, function() &#123;</span><br><span class="line">      assert.equal([1,2,3].indexOf(4), -1);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>启动终端/命令行工具(git bash)，在当前项目目录下 输入命令 mocha</p><p><code>mocha</code><br>运行结果如下：</p><p><img src="/2018/11/03/mocha/1.png" alt="运行结果" title="运行结果"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">lenovo@LAPTOP-QGCH84J8 MINGW64 /e/workSpace/study/1-单元测试/test</span><br><span class="line">$ mocha</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  Array</span><br><span class="line">    #indexOf()</span><br><span class="line">      √ should return -1 when the value is not present</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  1 passing (5ms)</span><br></pre></td></tr></table></figure><p>在 package.json 中设置脚本:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;mocha&quot;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>然后运行测试：<br><code>npm test</code></p><h1 id="mocha-的两个函数"><a href="#mocha-的两个函数" class="headerlink" title="mocha 的两个函数"></a>mocha 的两个函数</h1><p>mocha 是一个测试框架，即组织并执行测试。写测试的时候要调用两个基本的函数：描述函数 describe()和它函数 it(),在上面的例子中都有用到。</p><ol><li>描述函数 describe()是 mocha 将测试分组的一种方法，可以把多个测试嵌套在一个组里，想要嵌套多深就嵌套多深。describe()有两个参数，第一个是测试组的名字，第二个是实际执行的函数。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">describe(&apos;string name&apos;,function()&#123;</span><br><span class="line"></span><br><span class="line">// 这里可以嵌套更多的描述函数describe()，也可以写实际的测试。</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="2"><li>它函数 it()用于单独的测试用例。在一个 describe()中可以嵌套多个 it()函数。it()函数有两个参数，第一个参数是一个字符串说明测试的目的，第二个是实际执行的函数，里面是具体的测试。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">it(&apos;it name&apos;,function()&#123;</span><br><span class="line">    // 在这里写测试用例</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="编写-js-模块文件的测试脚本"><a href="#编写-js-模块文件的测试脚本" class="headerlink" title="编写 js 模块文件的测试脚本"></a>编写 js 模块文件的测试脚本</h1><p>在项目中添加 add.js 文件，并在其中添加如下 add 模块代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//add.js</span><br><span class="line">function add(a, b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = add;</span><br></pre></td></tr></table></figure><p>添加 test/add.test.js 文件，并在其中添加 add 的测试脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// add.test.js</span><br><span class="line"></span><br><span class="line">var assert = require(&apos;assert&apos;);</span><br><span class="line"></span><br><span class="line">var add = require(&apos;../add.js&apos;);</span><br><span class="line"></span><br><span class="line">describe(&apos;add函数的测试&apos;, function () &#123;</span><br><span class="line">    it(&apos;3加4应该等于7&apos;, function () &#123;</span><br><span class="line">        assert.equal(add(3, 4), 7);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在终端输入<br><code>npm test</code></p><p>终端运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">lenovo@LAPTOP-QGCH84J8 MINGW64 /e/workSpace/study/1-单元测试/test</span><br><span class="line">$ npm test</span><br><span class="line"></span><br><span class="line">&gt; @ test E:\workSpace\study\1-单元测试\test</span><br><span class="line">&gt; mocha</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  add函数的测试</span><br><span class="line">    √ 3加4应该等于7</span><br><span class="line"></span><br><span class="line">  Array</span><br><span class="line">    #indexOf()</span><br><span class="line">      √ should return -1 when the value is not present</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  2 passing (6ms)</span><br></pre></td></tr></table></figure><h1 id="多次调用-done"><a href="#多次调用-done" class="headerlink" title="多次调用 done()"></a>多次调用 done()</h1><p>如果使用基于回调的异步测试，如果 mocha 多次调用 done(),则会抛出 Error，这对于捕获意外的多次回调非常方便。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">it(&apos;double done&apos;, function(done) &#123;</span><br><span class="line">  // Calling `done()` twice is an error</span><br><span class="line">  setImmediate(done);</span><br><span class="line">  setImmediate(done);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>运行上述测试将会得到下面的错误信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">lenovo@LAPTOP-QGCH84J8 MINGW64 /e/workSpace/study/1-单元测试/test</span><br><span class="line">$ npm test</span><br><span class="line"></span><br><span class="line">&gt; @ test E:\workSpace\study\1-单元测试\test</span><br><span class="line">&gt; mocha</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  √ double done</span><br><span class="line">  1) double done</span><br><span class="line">  add函数的测试</span><br><span class="line">    √ 3加4应该等于7</span><br><span class="line"></span><br><span class="line">  Array</span><br><span class="line">    #indexOf()</span><br><span class="line">      √ should return -1 when the value is not present</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  3 passing (9ms)</span><br><span class="line">  1 failing</span><br><span class="line"></span><br><span class="line">  1) double done:</span><br><span class="line">     Error: done() called multiple times</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">npm ERR! Test failed.  See above for more details.</span><br></pre></td></tr></table></figure><h1 id="ASSERTIONS-断言"><a href="#ASSERTIONS-断言" class="headerlink" title="ASSERTIONS(断言)"></a>ASSERTIONS(断言)</h1><p>mocha 允许你使用任意你喜欢的断言库，在上面的 add 例子中我们使用了 node.js 内置的 assert 模块作为断言。如果抛出一个错误，它就能够运行。这意味着你能够使用下面的这些仓库，比如：</p><p><a href="https://github.com/shouldjs/should.js" target="_blank" rel="noopener">should.js</a></p><p><a href="https://github.com/Automattic/expect.js" target="_blank" rel="noopener">expect.js</a></p><p><a href="https://www.chaijs.com/" target="_blank" rel="noopener">chai</a></p><p><a href="https://github.com/tj/better-assert" target="_blank" rel="noopener">better-assert</a></p><p><a href="http://unexpected.js.org/" target="_blank" rel="noopener">unexpect</a></p><h1 id="异步测试"><a href="#异步测试" class="headerlink" title="异步测试"></a>异步测试</h1><p>使用 mocha 测试异步代码是再简单不过了。只需要在测试完成的时候调用一下回调函数即可。通过添加一个回调函数(通常命名为 done)给 it()方法，Mocha 就会知道，它应该等这个函数被调用的时候才能完成测试。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">describe(&apos;User&apos;, function() &#123;</span><br><span class="line">    describe(&apos;#save()&apos;, function() &#123;</span><br><span class="line">        it(&apos;should save without error&apos;, function() &#123;</span><br><span class="line">            var user = new User(&apos;Luna&apos;)</span><br><span class="line">            user.save(function(err) &#123;</span><br><span class="line">                if(err) done(err);</span><br><span class="line">                else done()</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>也可以让事情变得更简单，因为 done()函数接收一个 err，所以，我们可以直接按照下面的使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">describe(&apos;User&apos;, function() &#123;</span><br><span class="line">    describe(&apos;#save()&apos;, function() &#123;</span><br><span class="line">        it(&apos;should save without error&apos;, function(done) &#123;</span><br><span class="line">            var user = new User(&apos;Luna&apos;)</span><br><span class="line">            user.save(done)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="promise-测试"><a href="#promise-测试" class="headerlink" title="promise 测试"></a>promise 测试</h1><p>同时，除了使用 done()回调函数，你也可以返回一个 Promise。这种方式对于测试那些返回 promies 的方法是实用的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">beforeEach(function() &#123;</span><br><span class="line">  return db.clear()</span><br><span class="line">    .then(function() &#123;</span><br><span class="line">      return db.save([tobi, loki, jane]);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">describe(&apos;#find()&apos;, function() &#123;</span><br><span class="line">  it(&apos;respond with matching records&apos;, function() &#123;</span><br><span class="line">    return db.find(&#123; type: &apos;User&apos; &#125;).should.eventually.have.length(3);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h1><p>mocha 提供 4 种钩子函数：before()、after()、beforeEach()、afterEach()，这些钩子函数可以用来在用例集/用例函数开始执行之前/结束执行之后，进行一些环境准备或者环境清理的工作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">describe(&apos;hooks&apos;, function() &#123;</span><br><span class="line"></span><br><span class="line">  before(function() &#123;</span><br><span class="line">    // runs before all tests in this block</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  after(function() &#123;</span><br><span class="line">    // runs after all tests in this block</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  beforeEach(function() &#123;</span><br><span class="line">    // runs before each test in this block</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  afterEach(function() &#123;</span><br><span class="line">    // runs after each test in this block</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  // test cases</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><hr><p><strong><em>愿圣光与你同在！</em></strong></p><p>如本文有任何问题欢迎指正，谢谢！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;自出道以来一直想写个单元测试来的，但是一直都在想，终于今天开始写了，也算迈出了小小的一步。&lt;/p&gt;
&lt;h1 id=&quot;INSTALLATION-安装&quot;&gt;&lt;a href=&quot;#INSTALLATION-安装&quot; class=&quot;headerlink&quot; title=&quot;INSTALLAT
      
    
    </summary>
    
    
    
      <category term="mocha, TDD , 测试" scheme="http://yoursite.com/tags/mocha-TDD-%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>github+hexo搭建个人博客</title>
    <link href="http://yoursite.com/2018/10/26/github+hexo/"/>
    <id>http://yoursite.com/2018/10/26/github+hexo/</id>
    <published>2018-10-26T10:16:54.000Z</published>
    <updated>2020-01-06T07:25:28.835Z</updated>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=32192436&auto=0&height=66"></iframe><p>以前就想折腾这个 github 的博客，怎奈各种加班没有时间，最近比较闲就拿出来折腾了，其实人家还是很兴奋的了啦，折腾出来的时候还是很有成就感的，终于有了自己的博客了，还是自己一手搭建的，虽然其中也踩了不少的坑，傻笑+手舞足蹈，你没有看错，嗯，就是一个疯子。然后这个网易云音乐就舍不得删了，哈哈，至于网易云音乐的外链播放器怎么生成，自己百度吧，哈哈哈。</p><p>博客的创建与发布</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo new &apos;文件名&apos; //会在source/_posts创建一个文件名.md文件</span><br><span class="line"></span><br><span class="line">hexo s  // 本地预览效果, https://localhost:4000</span><br><span class="line"></span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d //发布到 github</span><br></pre></td></tr></table></figure><p><a href="https://13hua.github.io/" target="_blank" rel="noopener">博客主页地址</a></p><h4 id="Project-setup"><a href="#Project-setup" class="headerlink" title="Project setup"></a>Project setup</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">hexo g //生成</span><br><span class="line">hexo s //启动服务 开启本地预览服务 http://localhost:4000</span><br></pre></td></tr></table></figure><h2 id="常用hexo命令"><a href="#常用hexo命令" class="headerlink" title="常用hexo命令"></a>常用hexo命令</h2><p>####常见命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;postName&quot; # 新建文章</span><br><span class="line">hexo new page &quot;postName&quot; # 新建页面</span><br><span class="line">hexo generate # 生成静态页面至public目录</span><br><span class="line">hexo server # 开启预览访问段港口（默认端口4000）</span><br><span class="line">hexo deploy # 部署到github</span><br><span class="line">hexo help # 查看帮助</span><br><span class="line">hexo version # 查看hexo的版本</span><br></pre></td></tr></table></figure></p><h4 id="缩写"><a href="#缩写" class="headerlink" title="缩写"></a>缩写</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo n === hexo new</span><br><span class="line">hexo g === hexo generate</span><br><span class="line">hexo s === hexo server</span><br><span class="line">hexo d === hexo deploy</span><br></pre></td></tr></table></figure><h4 id="组合命令"><a href="#组合命令" class="headerlink" title="组合命令"></a>组合命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo s -g #生成本地预览</span><br><span class="line">hexo d -g #生成并上传</span><br></pre></td></tr></table></figure><p>主线是按照 <a href="https://www.jianshu.com/p/a52b68794a6b" target="_blank" rel="noopener">hexo 创建个人博客（附加插入音乐、分享、评论、标签页、搜索）</a>这个教程来做的，多余的话不说了，只做一些补充。</p><h3 id="部分补充说明"><a href="#部分补充说明" class="headerlink" title="部分补充说明"></a>部分补充说明</h3><ol><li><p>编辑器我使用的是 vs code，很好用。</p></li><li><p>这份简书博文中所说的评论系统“多说”已经挂了，参考 <a href="https://blog.csdn.net/weixin_41196185/article/details/79178780" target="_blank" rel="noopener">hexo+github 打造个人博客系列之评论系统</a> 这篇博文，我选用了 github 的 gitment，分享用 jiathis，百度，但是这两种都是 http 的，不支持 https，我就放过去了，没有再折腾。</p></li><li><p>搜索这一部分<a href="http://theme-next.iissnan.com/third-party-services.html#algolia-search" target="_blank" rel="noopener">next 主题官网 Algolia 搜索</a>也有介绍,我用的是 local search，还不错的样子<img src="/2018/10/26/github+hexo/search-1.png" alt="搜索效果图" title="搜索效果图"></p></li><li><p>有了这些经验，其他的配置都可以根据<a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">next 主题官网</a>自己配置了</p></li><li><p><a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">next 主题官网</a></p></li><li><p><a href="https://www.jianshu.com/p/8d28027fec76" target="_blank" rel="noopener">文章图片的插入</a></p></li></ol><h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><ol><li><p>在本地预览 （hexo s） 的时候是成功的，但是部署到 github 上的时候，样式没有加载出来。</p><p>通过控制台查看样式文件报 404，是因为 url 地址不对。需要修改_config.yml 文件中的 url 地址和根目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># URL</span><br><span class="line">## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;</span><br><span class="line">url: https://banjingwei.github.io/ban.github.io</span><br><span class="line">root: /ban.github.io/</span><br><span class="line">permalink: :year/:month/:day/:title/</span><br><span class="line">permalink_defaults:</span><br></pre></td></tr></table></figure><p>url 是 github pages 给我们分配的网址</p></li><li><p>gitment 评论 Error：Not Found<br>通常是 repo 或者 owner 配置不对，owner 是申请时候填的,下面是我的 repo 配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">github_repo: 13hua.github.io, # MUST HAVE, The repo you use to store Gitment comments</span><br></pre></td></tr></table></figure></li><li><p>gitment 评论初始化的时候弹出 Error：validation failed。</p><p>issue 的标签 label 有长度限制！labels 的最大长度限制是 50 个字符。</p><p>修改 next/layout/_third-party/comments/gitment.swig</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id: window.location.pathname</span><br></pre></td></tr></table></figure><p>找到上面一行，将 id 的值修改成如下即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id: &apos;&#123;&#123; page.title &#125;&#125;&apos;</span><br></pre></td></tr></table></figure><p>但是，title 也有可能超过 50 个字符怎么办呢？修改成日期不就可以了么，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id: &apos;&#123;&#123; page.date &#125;&#125;&apos;</span><br></pre></td></tr></table></figure><ol start="4"><li>赞赏功能的配置，图片放在 next/source/images 下，在<font color="#9954BB">主题配置文件</font>中做出如下配置，其中 13hua.github.io 是我的 blog 的 repo，改成你自己的即可。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">reward_comment: 坚持原创技术分享，您的支持将鼓励我继续创作！</span><br><span class="line">wechatpay: /13hua.github.io/images/wechatpay.jpg</span><br><span class="line">alipay: /13hua.github.io/images/alipay.jpg</span><br></pre></td></tr></table></figure><hr><p><strong><em>愿圣光与你同在！</em></strong></p><p>如本文有任何问题欢迎指正，谢谢！</p><blockquote><p>致谢：</p></blockquote><ol><li><p><a href="https://www.jianshu.com/p/a52b68794a6b" target="_blank" rel="noopener">hexo 创建个人博客（附加插入音乐、分享、评论、标签页、搜索）</a></p></li><li><p><a href="https://blog.csdn.net/weixin_41196185/article/details/79178780" target="_blank" rel="noopener">hexo+github 打造个人博客系列之评论系统</a></p></li><li><p><a href="https://segmentfault.com/a/1190000009544924" target="_blank" rel="noopener">hexo 的 next 主题个性化配置教程</a></p></li><li><p><a href="https://www.jianshu.com/p/8d28027fec76" target="_blank" rel="noopener">文章图片的插入</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=
      
    
    </summary>
    
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
</feed>
