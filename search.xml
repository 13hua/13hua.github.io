<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[TCP/IP协议]]></title>
    <url>%2F2019%2F12%2F24%2FTCP-IP%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[网络基础TCP/IP为了理解http，我们有必要事先了解一下TCP/IP协议族。 通常使用的网络（包括互联网）是在TCP/IP的基础上运作的，而HTTP属于它的一个子集。 计算机与网络设备要相互通信，双方就必须基于相同的方法。如，如何探测到通信目标、有哪一边先发起通信、使用哪种语言进行通信、怎样结束通信等规则都需要事先确定。不同的硬件、操作系统之间的通信，所有的这一切都需要一种规则。而我们把这种规则称为协议(protocol)。把与互联网相关联的协议集合起来总称为TCP/IP。也有一种说法认为TCP/IP是指TCP和IP这两种协议，还有一种说法认为TCP/IP是在IP协议的通信过程中，使用到的协议族的总称。 TCP/IP的分层管理TCP/IP协议族按层次分别分为4层：应用层、传输层、网络层、数据链路层。 类似于代码的模块化，无疑TCP/IP协议族分层是很有好处的，各层各司其职互不干扰，如果需要更换其中的某一层只需换掉这一层即可。 各层作用如下： 应用层应用层决定了向用户提供应用服务时的通信活动。TCP/IP协议族内预存了各类通用的应用服务。比如：FTP(File Transfer Protocol 文件传输协议)和DNS(Domain Name System 域名系统)就是其中的两类。HTTP协议也处于该层。 传输层传输层对上层应用层提供处于网络连接中的两台计算机之间的数据传输。 在传输层有两个性质不同的协议：TCP(Transmission Control Protocol 传输控制协议)和UDP(User Data Protocol 用户数据报协议) 网络层网络层又名网络互连层。网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数据单位。该层规定了通过怎样的路径（所谓的传输路线）到达对方计算机，并把数据包传送给对方。 数据链路层数据链路层又名链路层、网络接口层。用来处理网路的硬件部分。包括控制操作系统、硬件的设备驱动、NIC(Network Interface Card 网络适配器即 网卡)，及光纤等物理可见部分（还包括连接等一切传输媒介）。硬件上的范畴均在数据链路层的作用范围之内。 TCP/IP通信传输发送端从应用层往下走，接收端从数据链路层往上走。用http举例来说明： 首先，作为发送端的客户端在应用层（http协议）发粗一个想看某个web页面的http请求 接着，为了传输方便，在传输层（TCP协议）把从应用层处收到的数据（HTTP请求报文）进行分割，并在各个报文上打上标记序号及端口号后转发给网络层。 在网络层（IP协议）。增加作为通信目的地的MAC（Media Access Control Address 物理地址，一般是不变的）地址后转发给链路层。这样一来发往网络的通信请求就准备齐全了。 接收端的服务器在链路层接收到数据，按序往上层发送，一直到应用层。当传输到应用层，才能算真正接收到由客户端发送过来的HTTP请求。 发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息。反之，按接收端在层与层传输数据时，每经过一层时会把对应的首部消去。 这种把数据信息包装起来的做法称为封装（encapsulate） 概念解释： IP是一种协议，一种把各种数据包传送给对方的协议。 IP地址是指节点被分配到的地址，IP地址可以和MAC地址进行配对，IP地址可变换 MAC地址是指网卡所属的固定地址，MAC地址基本上不会更改。 ARP协议凭借MAC地址进行通信IP之间的通信依赖MAC地址。在网络上，通信双方在同一局域网（LAN）内的情况是很少的，通常是经过多台计算机和网络设备中转才能连接到对方。而在进行中转时，会利用下一站中转设备的MAC地址来搜索下一个中转目标。这时会采用ARP协议（Address Resolution Protocol）。ARP是一种用以解析地址的协议，根据通信方的IP地址就可以反查出对应的MAC地址。]]></content>
      <tags>
        <tag>TCP/IP协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[canvas优化]]></title>
    <url>%2F2019%2F12%2F24%2Fcanvas%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[canvas是HTML5出的一个标签，用js控制绘制图形。canvas标签一定要有width和height，不能在style中定义width和height，否则会出现变形、缩放等一系列问题。 我们先来了解一下canvas的渲染 canvas上下文是状态机canvas API 都在其上下文对象context上抵用。1const context = canvas.getContext(&apos;2d&apos;); context是一个状态机。你可以改变context的若干状态，而几乎所有的渲染操作，最终的效果与context本身的状态有关系。 123context.lineWidth = 5;context.strokeStyle=&quot;f00&quot;context.strokeRect(100,100,200,200) context.lineWidth 的赋值开销要远远大于普通对象赋值的开销。context不是一个普通的对象，当你调用了context.lineWidth = 5 时，浏览器会需要立刻去做一些事情，这样你下次调用诸如stroke或strokeRect等API时，画出来的正好是5px宽了。（不难想象，这也是一种优化，否则，这些事情就要等到下次stroke之前做，更加会影响性能）。 我们执行以下赋值操作10^6次 12345// 10^6timessomePlainObject.lineWidth = 5; // 3ms context.lineWidth = 5; // 40mscontext.lineWidth = &apos;Hello World!&apos;; // 140mscontext.lineWidth = &#123;&#125;; // 600ms 参考文章MDN：canvas 性能 https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial/Optimizing_canvas Canvas 最佳实践（性能篇）：https://fed.taobao.org/blog/taofed/do71ct/canvas-performance/?spm=taofed.blogs.blog-list.2.6b365ac8l8NLf9]]></content>
      <tags>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mpvue微信小程序踩坑笔记(一)]]></title>
    <url>%2F2019%2F01%2F19%2Fwx-study-1%2F</url>
    <content type="text"><![CDATA[demo源码 mpvue可以使用vue的基本语法来开发小程序，可以使用vux，flyio等来辅助开发，方便快捷高效开发。当然这其中还有诸多限制。官方文档指出的问题就不一一罗列了，不清楚的童鞋请看这里 mpvue官方文档 另外看到了一份写的还不错的踩坑指南 ，共勉 下面来说说我踩的坑。 一、 swiper组件的问题1. swiper组件自适应高度问题解决思路是：获取屏幕宽度，获取图片的宽高，然后等比设置当前屏幕宽度下swiper的高度。因为load事件只在图片第一次加载的时候执行，所以取所有图片高度的最大值即可12345678910111213141516171819&lt;swiper :current=&quot;currSwiperItem&quot; skip-hidden-item-layout=&quot;true&quot; @change=&quot;switchItem(&apos;switchItem&apos;,$event)&quot; :style=&quot;swiperImgH&quot;&gt; &lt;swiper-item v-for=&quot;(list,index) in swiperList&quot; :key=&quot;index&quot;&gt; &lt;img class=&quot;img&quot; :src=&quot;list.imgPath&quot; @load=&quot;calcImgH&quot; mode=&quot;widthFix&quot; alt=&quot;&quot;&gt; &lt;/swiper-item&gt;&lt;/swiper&gt; /** * 动态计算swiper图片的高度 */calcImgH: async function (e) &#123; let winWidth = wx.getSystemInfoSync().windowWidth; // 获取当前屏幕的宽度 let imgH = e.mp.detail.height; // 图片高度 let imgW = e.mp.detail.width; if (imgH &gt; this.curImgH) &#123; this.curImgH = imgH; &#125; this.swiperImgH = `height:$&#123;winWidth * this.curImgH / imgW&#125;px`;&#125;, 2. swiper组件的current一定要写，如果不写就会出现只显示两张图片，从第三张开始高度均为0.如果出现这种问题，请优先查看是否定义了current二、v-show不能使用，请使用v-if，具体原因应该是mpvue的问题，可能是编译的时候出了问题没有编译成wx：show三、canvas保存图片的时候显示的是上一张图片，这里需要做重置处理，这个不是mpvue的问题四、关于文件命名问题例如：我想把 /pages/list/index.vue 中的js代码提出来 单独放在 /pageslist/index.js中，这个时候这个index.js文件命名就有问题了，在微信开发工具中会提示找不到/pages/list/main.wxml 文件，我想可能是因为list下出现了两个index文件mpvue不知道编译哪一个，所以才出现了问题的吧，把js文件改成除了index外的任何名字就好了。 五、vux的使用，在utils等纯js文件中使用store,在vue中我们会使用引入文件的方式使用，没有任何问题，例如： 123import store from &apos;./store.js&apos; console.log(store.status); 但是在mpvue中这样直接引入store使用是有问题的,这样写不会报错，在mpvue中这里的store和vue实例中的this.$store不是同一个实例，即 这里的store.status !== this.$store.status。也就是说修改store.status的值，this.$store.status并不会做任何的改变，他们俩没有关系。 六、canvas 问题因为canvas使用的是原生组件，z-index并不会影响它的层级，永远是在最上层的，如果需要做弹窗遮罩就需要使用 cover-view 或者cover-image ，这里需要注意的是cover-view 或者cover-image必须要写在canvas上下文的后面，如果写在前面还是一样无法遮住。 七、scroll-view 上拉加载下拉刷新在@touchend=&quot;scrollTouchEnd&quot; 事件中 对满足条件的 scroll-top 赋值之后并没有 并没有页面做出实质对的改变，因为对同一个值做相同的复制操作的时候mpvue并没有执行这个赋值动作，解决方法是再赋一个不同的值，这样就会做出改变了，代码如下： 1234567891011121314151617scrollTouchEnd() &#123; console.log(&apos;scrollTouchEnd&apos;); if (this.scrollingTop &lt; 80) &#123; console.log(&apos;下拉刷新&apos;); this.refresh(); this.scrolledTop = 0; this.scrolledTop = 80; &#125; if (this.scrollHeight - this.scrollingTop - this.scrollWrapHeight &lt;= 80) &#123; console.log(&apos;上拉加载&apos;); this.loadMore(); this.scrolledTop = this.scrollHeight - this.scrollWrapHeight; this.scrolledTop = this.scrollHeight - this.scrollWrapHeight - 80; &#125;&#125; 愿圣光与你同在！ 如本文有任何问题欢迎指正，谢谢！]]></content>
      <tags>
        <tag>mpvue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于单元测试mocha的学习笔记]]></title>
    <url>%2F2018%2F11%2F03%2Fmocha%2F</url>
    <content type="text"><![CDATA[自出道以来一直想写个单元测试来的，但是一直都在想，终于今天开始写了，也算迈出了小小的一步。 INSTALLATION(安装)全局安装，(非必需，虽然很多文章都要求全局安装，但是廖雪峰大大建议尽量不要全局安装，因为全局模块会影响到所有 Node.js 的工程) npm install --global mocha 项目局部安装 npm install --save-dev mocha 如果 npm 网速比较慢，建议使用 yarn。 GETTING STARTED(起步)新建项目，并在项目中安装 mocha。新建一个 test 文件夹，所有的 test 文件就都放在这个文件夹下，mocha 默认会执行 test 目录下的所有测试，不要去改变默认目录。 在 test.js 中写下如下代码： 12345678var assert = require(&apos;assert&apos;);describe(&apos;Array&apos;, function() &#123; describe(&apos;#indexOf()&apos;, function() &#123; it(&apos;should return -1 when the value is not present&apos;, function() &#123; assert.equal([1,2,3].indexOf(4), -1); &#125;); &#125;);&#125;); 启动终端/命令行工具(git bash)，在当前项目目录下 输入命令 mocha mocha运行结果如下： 12345678910lenovo@LAPTOP-QGCH84J8 MINGW64 /e/workSpace/study/1-单元测试/test$ mocha Array #indexOf() √ should return -1 when the value is not present 1 passing (5ms) 在 package.json 中设置脚本: 123&quot;scripts&quot;: &#123; &quot;test&quot;: &quot;mocha&quot; &#125;, 然后运行测试：npm test mocha 的两个函数mocha 是一个测试框架，即组织并执行测试。写测试的时候要调用两个基本的函数：描述函数 describe()和它函数 it(),在上面的例子中都有用到。 描述函数 describe()是 mocha 将测试分组的一种方法，可以把多个测试嵌套在一个组里，想要嵌套多深就嵌套多深。describe()有两个参数，第一个是测试组的名字，第二个是实际执行的函数。 12345describe(&apos;string name&apos;,function()&#123;// 这里可以嵌套更多的描述函数describe()，也可以写实际的测试。&#125;); 它函数 it()用于单独的测试用例。在一个 describe()中可以嵌套多个 it()函数。it()函数有两个参数，第一个参数是一个字符串说明测试的目的，第二个是实际执行的函数，里面是具体的测试。 123it(&apos;it name&apos;,function()&#123; // 在这里写测试用例&#125;); 编写 js 模块文件的测试脚本在项目中添加 add.js 文件，并在其中添加如下 add 模块代码 123456//add.jsfunction add(a, b) &#123; return a + b;&#125;module.exports = add; 添加 test/add.test.js 文件，并在其中添加 add 的测试脚本 1234567891011// add.test.jsvar assert = require(&apos;assert&apos;);var add = require(&apos;../add.js&apos;);describe(&apos;add函数的测试&apos;, function () &#123; it(&apos;3加4应该等于7&apos;, function () &#123; assert.equal(add(3, 4), 7); &#125;)&#125;) 在终端输入npm test 终端运行结果： 1234567891011121314151617lenovo@LAPTOP-QGCH84J8 MINGW64 /e/workSpace/study/1-单元测试/test$ npm test&gt; @ test E:\workSpace\study\1-单元测试\test&gt; mocha add函数的测试 √ 3加4应该等于7 Array #indexOf() √ should return -1 when the value is not present 2 passing (6ms) 多次调用 done()如果使用基于回调的异步测试，如果 mocha 多次调用 done(),则会抛出 Error，这对于捕获意外的多次回调非常方便。 12345it(&apos;double done&apos;, function(done) &#123; // Calling `done()` twice is an error setImmediate(done); setImmediate(done);&#125;); 运行上述测试将会得到下面的错误信息 12345678910111213141516171819202122232425262728lenovo@LAPTOP-QGCH84J8 MINGW64 /e/workSpace/study/1-单元测试/test$ npm test&gt; @ test E:\workSpace\study\1-单元测试\test&gt; mocha √ double done 1) double done add函数的测试 √ 3加4应该等于7 Array #indexOf() √ should return -1 when the value is not present 3 passing (9ms) 1 failing 1) double done: Error: done() called multiple timesnpm ERR! Test failed. See above for more details. ASSERTIONS(断言)mocha 允许你使用任意你喜欢的断言库，在上面的 add 例子中我们使用了 node.js 内置的 assert 模块作为断言。如果抛出一个错误，它就能够运行。这意味着你能够使用下面的这些仓库，比如： should.js expect.js chai better-assert unexpect 异步测试使用 mocha 测试异步代码是再简单不过了。只需要在测试完成的时候调用一下回调函数即可。通过添加一个回调函数(通常命名为 done)给 it()方法，Mocha 就会知道，它应该等这个函数被调用的时候才能完成测试。 1234567891011describe(&apos;User&apos;, function() &#123; describe(&apos;#save()&apos;, function() &#123; it(&apos;should save without error&apos;, function() &#123; var user = new User(&apos;Luna&apos;) user.save(function(err) &#123; if(err) done(err); else done() &#125;) &#125;) &#125;)&#125;) 也可以让事情变得更简单，因为 done()函数接收一个 err，所以，我们可以直接按照下面的使用： 12345678describe(&apos;User&apos;, function() &#123; describe(&apos;#save()&apos;, function() &#123; it(&apos;should save without error&apos;, function(done) &#123; var user = new User(&apos;Luna&apos;) user.save(done) &#125;) &#125;)&#125;) promise 测试同时，除了使用 done()回调函数，你也可以返回一个 Promise。这种方式对于测试那些返回 promies 的方法是实用的。 123456789101112beforeEach(function() &#123; return db.clear() .then(function() &#123; return db.save([tobi, loki, jane]); &#125;);&#125;);describe(&apos;#find()&apos;, function() &#123; it(&apos;respond with matching records&apos;, function() &#123; return db.find(&#123; type: &apos;User&apos; &#125;).should.eventually.have.length(3); &#125;);&#125;); 钩子函数mocha 提供 4 种钩子函数：before()、after()、beforeEach()、afterEach()，这些钩子函数可以用来在用例集/用例函数开始执行之前/结束执行之后，进行一些环境准备或者环境清理的工作。 1234567891011121314151617181920describe(&apos;hooks&apos;, function() &#123; before(function() &#123; // runs before all tests in this block &#125;); after(function() &#123; // runs after all tests in this block &#125;); beforeEach(function() &#123; // runs before each test in this block &#125;); afterEach(function() &#123; // runs after each test in this block &#125;); // test cases&#125;); 愿圣光与你同在！ 如本文有任何问题欢迎指正，谢谢！]]></content>
      <tags>
        <tag>mocha, TDD , 测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github+hexo搭建个人博客]]></title>
    <url>%2F2018%2F10%2F26%2Fgithub%2Bhexo%2F</url>
    <content type="text"><![CDATA[以前就想折腾这个 github 的博客，怎奈各种加班没有时间，最近比较闲就拿出来折腾了，其实人家还是很兴奋的了啦，折腾出来的时候还是很有成就感的，终于有了自己的博客了，还是自己一手搭建的，虽然其中也踩了不少的坑，傻笑+手舞足蹈，你没有看错，嗯，就是一个疯子。然后这个网易云音乐就舍不得删了，哈哈，至于网易云音乐的外链播放器怎么生成，自己百度吧，哈哈哈。 博客的创建与发布 12345hexo new &apos;文件名&apos; //会在source/_posts创建一个文件名.md文件hexo s // 本地预览效果, https://localhost:4000hexo clean &amp;&amp; hexo g &amp;&amp; hexo d //发布到 github 博客主页地址 Project setup123hexo g //生成hexo s //启动服务 开启本地预览服务 http://localhost:4000 常用hexo命令####常见命令1234567hexo new &quot;postName&quot; # 新建文章hexo new page &quot;postName&quot; # 新建页面hexo generate # 生成静态页面至public目录hexo server # 开启预览访问段港口（默认端口4000）hexo deploy # 部署到githubhexo help # 查看帮助hexo version # 查看hexo的版本 缩写1234hexo n === hexo newhexo g === hexo generatehexo s === hexo serverhexo d === hexo deploy 组合命令12hexo s -g #生成本地预览hexo d -g #生成并上传 主线是按照 hexo 创建个人博客（附加插入音乐、分享、评论、标签页、搜索）这个教程来做的，多余的话不说了，只做一些补充。 部分补充说明 编辑器我使用的是 vs code，很好用。 这份简书博文中所说的评论系统“多说”已经挂了，参考 hexo+github 打造个人博客系列之评论系统 这篇博文，我选用了 github 的 gitment，分享用 jiathis，百度，但是这两种都是 http 的，不支持 https，我就放过去了，没有再折腾。 搜索这一部分next 主题官网 Algolia 搜索也有介绍,我用的是 local search，还不错的样子 有了这些经验，其他的配置都可以根据next 主题官网自己配置了 next 主题官网 文章图片的插入 遇到的问题 在本地预览 （hexo s） 的时候是成功的，但是部署到 github 上的时候，样式没有加载出来。 通过控制台查看样式文件报 404，是因为 url 地址不对。需要修改_config.yml 文件中的 url 地址和根目录 123456# URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: https://banjingwei.github.io/ban.github.ioroot: /ban.github.io/permalink: :year/:month/:day/:title/permalink_defaults: url 是 github pages 给我们分配的网址 gitment 评论 Error：Not Found通常是 repo 或者 owner 配置不对，owner 是申请时候填的,下面是我的 repo 配置。 1github_repo: 13hua.github.io, # MUST HAVE, The repo you use to store Gitment comments gitment 评论初始化的时候弹出 Error：validation failed。 issue 的标签 label 有长度限制！labels 的最大长度限制是 50 个字符。 修改 next/layout/_third-party/comments/gitment.swig 1id: window.location.pathname 找到上面一行，将 id 的值修改成如下即可： 1id: &apos;&#123;&#123; page.title &#125;&#125;&apos; 但是，title 也有可能超过 50 个字符怎么办呢？修改成日期不就可以了么， 1id: &apos;&#123;&#123; page.date &#125;&#125;&apos; 赞赏功能的配置，图片放在 next/source/images 下，在主题配置文件中做出如下配置，其中 13hua.github.io 是我的 blog 的 repo，改成你自己的即可。 123reward_comment: 坚持原创技术分享，您的支持将鼓励我继续创作！wechatpay: /13hua.github.io/images/wechatpay.jpgalipay: /13hua.github.io/images/alipay.jpg 致谢： hexo 创建个人博客（附加插入音乐、分享、评论、标签页、搜索） hexo+github 打造个人博客系列之评论系统 hexo 的 next 主题个性化配置教程 文章图片的插入 愿圣光与你同在！ 如本文有任何问题欢迎指正，谢谢！]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
